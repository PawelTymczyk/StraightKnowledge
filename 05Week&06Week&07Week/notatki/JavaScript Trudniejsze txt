https://github.com/leonardomso/33-js-concepts

==========
EVENT LOOP

call stack - stos wywoo (funkcji najczciej) - bufor typu LiFo - wszystie wywoaa pokolejni s 
zbierane i od odstatniego dorzuconego zostaj one wywoane
Maksymalna pojemno stosu to 16 000 wywoa

call quene - kolejka wiadomoci - FiFo wywoania wiadomoci s wywolywane w kolejnoci takiej jakiej si pojawiy na tej kolejce 

Heap - sterta - przechowywane s tam dynamicznie tworzone struktury danych w czasie trwania samego programu.
Za zwalnianie pamici z nieu偶ywanych element贸w odpowiada garbage collector.

setTimeout() - podana jest minimalna warto w milisekundach, po kt贸rej wykona si kod 
- mo偶e wywoa si p贸藕niej ni偶 zakadane z powodu innych element贸w w stosie lub kolejce

mikrotaski - obszar kt贸ry obsuguje kod asynchroniczny - z tego obszaru mo偶e podczas jednej ptli zej wicej ni偶 jeden element 
znajduj si tam midzy innymi setTimeout(), Promise oraz rcznie napisane funkcje asynchroniczne. 

Fajny przykad event loop'a: https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif


=====================
CALL() APPLY() BIND()

call - redefiniuje instancj obiektu na czas wywoania, ka偶dy element funkcji wywoujcej jest samodzielnym elementem
* cylinder.volume.call({pi: 3.14159}, 2, 4);


apply - redefiniuje instancj obiektu na czas wywoania, pocztkowe elementy s wartociami obiektu,
natomiast elementy funkcji mo偶na poda w tablicy
* cylinder.volume.apply({pi: 3.14159}, [2, 4]);

Wniosek: call i apply s do siebie nawzajem stosunkowo podobne


bind - zwraca now instancj obiektu ze zmienionymi polami

WNIOSKI:
- Wszystkie 3 funkcje s podobne, pierwszy argument odnosi si do THIS tego obiektu.
- call i apply s wywoywane natychmiast, natomiast bind zwraca funkcj powizan, kt贸ra p贸藕niej mo偶e zosta wywoana.

==============================
OBJECT.CREATE() OBJECT.ASIGN()

create - tworzy obiekt na podstawie innego obiektu i traktuje go jako prototyp dla nowego

asign - zwraca poczony obiekt w jeden, pierwszy czony obiekt te偶 jest rozszerzony

=========
RECURSION - czyli rekurencja    

=======
PROMISE

Jest to proxy dla wartoci, kt贸ra w momencie wywoania nie jest jeszcze znana w momencie stworzenia.
Dziki temu  metody asynchroniczne zwracaj wartoci takie same jak metody synchroniczne.
Czyli promisy nie zwracaj natychmiastowo wartoci tylko "obietnic" dostarczenia tej wartoci, bd藕 innego wyniku.
Promisy mo偶e mie jeden z trzech stan贸w:
- pocztkowy
- speniony
- odrzucony

Przykadowy promis: 
const wait = time => new Promise((resolve) => setTimeout(resolve, time));

wait(3000).then(() => console.log('Hello!')); // 'Hello!'

Struktura ka偶dego promosia wyglda w taki spos贸b
promise.then(
  onFulfilled?: Function,
  onRejected?: Function
) => Promise

wyapywanie error贸w nie musi by zawsze w catch - mo偶e by tak偶e obsu偶one za pomoc then'a

===========
ASYNC/AWAIT

Przykad: 

function scaryClown() {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve('ぁ');
    }, 2000);
  });
}

async function msg() {
  const msg = await scaryClown();
  console.log('Message:', msg);
}

msg(); // Message: ぁ <-- after 2 seconds


async / await - oznaczenie w ten spos贸b fregmentu kodu powoduje, 偶e staje si on asynchroniczny, ale z zachowaniem cech synchronicznoci
async i await r贸wnie偶 nie blokuj wwykonywania si oprogramowania

G贸wnym celem jest uproszczenie zachowania Promisa przy synchonicznym korzystaniu z nich.


async - nakazuje funkcji zwr贸cenie Promisa. Je偶eli kod zwr贸cony nie jest w postaci Promisa to JS automatycznie owarpowywuje go w Promisa.

await - sprawia, 偶e funkcja "czeka" na promisa i funkcja staje si r贸wnie偶 bardziej przejrzysa i czytelniejsza.
Await po prostu sprawia, 偶e JavaScript czeka, a偶 obietnica si ustabilizuje, a nastpnie kontynuuje z wynikiem. 
W midzyczasie, gdy czeka, silnik wykonuje inne zadania, takie jak uruchamianie skrypt贸w i obsuga zdarze. 
W ten spos贸b 偶adne zasoby procesora nie zostan utracone.

===============
DESIGN PATTERNS

U偶ytecznymi prototypami s:
- singleton - jest tylko jedna istniejca instancja na obszarze caego programu 
- moduu - s to po prostu klasy w JSie - jedn z najistotniejszych zalet tego rozwiazania jest hermetyzacja
- prototyp - jest to dziedziczenie prototypowym w JSie, jest u偶ywany g贸wnie do tworzenia struktury obiekt贸w kt贸re wps贸dziel midzy sob pewne cechy - pola

==============
Prototyp ARRAY

- reduce() - nie ogarniam tego na tyle dobrze, 偶eby swobodnie tego u偶ywa

- map() - zwraca tablic na kt贸rej wykonano jak funkcj
- filter() - zwraca tablic tylko dla tych element贸w tablicy, kt贸rych warunek jest prawdziwy
- join(',') - zwraca poczon ca tablic w jednego stringa i w nawiasach podaje si separator 
- every() - zwraca true, je偶eli ka偶dy z element贸w z tablicy spenia warunek
- some() - zwraca true, je偶eli kt贸rykolwiek z element贸w z tablicy spenia warunek
- concat() (przyjmuje wicej ni偶 jedn tablic) - zwraca zczon tablic z kilku innych tablic
- find() - zwraca pierwszy element kt贸ry spenia warunek funkcji
- findIndex() - zwraca index pierwszego elementu kt贸ry spenia warunek funkcji
- flat(X) - spacza tablic o X (liczba) poziom贸w - ciekawostka czyci puste miejsca w tablicy
oraz kiedy X bdzie wikszy ni偶 ilo poziom贸w to zrzuci po prostu do 1 wymiarowej tablicy
- includes() - zwraca true/false w zale偶noci od tego czy podany element zawiera si w elementach z tablicy
- isArray() - stwierdza czy element na kt贸rym zostaa wywoana metoda jest tablic
- lastIndexOf() - przeszukuje ca tabilc od koca i zwraca index ostatniego elemntu kt贸ry si pojawia w niej
gdy w tablicy nie ma tego elementu zwracana jest zamiast tego warto -1 
- pop() - zwraca ostatn wartoci z koca tablicy, a z niej samej wyrzuca ten element
- shift() zwraca pierwsz warto z pocztku tablicy, a z niej samej wyrzuca ten element 
- push() - dodaje now wartoci na koniec tablicy i zwraca jej now dugo
- unshift() - dodaje now warto na pocztek tablicy i zwraca jej now dugo
- reverse() - odwraca kolejno element贸w w tablicy ostatni staje si pierwszy ...
- slice(X, Y) - zwraca wycity fragment tablicy nie edytujc oryginau
- splice(X, Y) - Zmienia zawarto tablicy, dodajc nowe elementy podczas usuwania starych element贸w.



殴RDO:

https://github.com/leonardomso/33-js-concepts